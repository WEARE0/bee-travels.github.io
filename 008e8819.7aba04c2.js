(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{53:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return s})),a.d(t,"metadata",(function(){return c})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return u}));var n=a(2),o=a(6),r=(a(0),a(81)),i=a(84),s={id:"kube",title:"Kubernetes"},c={unversionedId:"kube",id:"kube",isDocsHomePage:!1,title:"Kubernetes",description:"Developers want to build applications. So how do we get our app out there in the real world? How do we make sure our app runs everywhere like it runs on our local dev environment?",source:"@site/docs/kube.md",slug:"/kube",permalink:"/docs/kube",version:"current",sidebar:"docs",previous:{title:"Python",permalink:"/docs/python"},next:{title:"Openshift",permalink:"/docs/openshift"}},l=[{value:"Why do I need Kubernetes and what can it do?",id:"why-do-i-need-kubernetes-and-what-can-it-do",children:[]},{value:"What Kubernetes is not",id:"what-kubernetes-is-not",children:[]},{value:"Why containers",id:"why-containers",children:[]},{value:"Kubernetes architecture",id:"kubernetes-architecture",children:[{value:"Kubernetes resource model",id:"kubernetes-resource-model",children:[]},{value:"Hardware",id:"hardware",children:[]},{value:"Software",id:"software",children:[]}]},{value:"Deployment Primitives",id:"deployment-primitives",children:[{value:"Pods",id:"pods",children:[]},{value:"Deployment",id:"deployment-1",children:[]},{value:"Service",id:"service",children:[]}]}],d={rightToc:l};function u(e){var t=e.components,a=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},d,a,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Developers want to build applications. So how do we get our app out there in the real world? How do we make sure our app runs everywhere like it runs on our local dev environment?"),Object(r.b)("p",null,"That\u2019s where Docker came in, however, Docker was not enough to run our application at scale. Kubernetes (",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/"}),"https://kubernetes.io/"),") helps us scale our application and gives us many other benefits. Nevertheless, all of these new tools comes with their own steep learning curve."),Object(r.b)("p",null,"We all probably heard of Kubernetes. If we did not hear about it yet we will."),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},Object(r.b)("strong",{parentName:"em"},"Kubernetes is a portable, extensible open-source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available."))),Object(r.b)("p",null,"Thats the definition of Kubernetes from the Kubernetes official documentation."),Object(r.b)("p",null,"Honestly that is not super clear what Kubernetes is from that documentation. And the reason it is not clear is because Kubernetes is many things. Its a container platform, a microservices platform a portable cloud platform and so much more."),Object(r.b)("p",null,"As Kelsey Hightower so very aptly put"),Object(r.b)("img",{alt:"Kelsey Tweets about K8s",src:Object(i.a)("img/kelsey.png")}),Object(r.b)("p",null,"Kubernetes is an abstraction on the infrastructure that helps automate many important but mundane and labor intensive work that was being done by many teams across the industry over and over and over again. K8s ","(","Short for Kubernetes",")"," gives a great starting point for most people and gives a way to standardize best practices across the industry. What most people don\u2019t even realize is that K8s is making the skills of platform and system engineers portable across industries and companies as well as making it easy for companies to find talent."),Object(r.b)("p",null,"I still don\u2019t think I am anywhere closer to defining what K8s actually is. I don\u2019t think there is a short and concise definition for it. Instead lets talk about how K8s came to be, what it is made of and what problems it solves and maybe we will have a clearer view about the purpose of K8s."),Object(r.b)("h2",{id:"why-do-i-need-kubernetes-and-what-can-it-do"},"Why do I need Kubernetes and what can it do?"),Object(r.b)("p",null,"Kubernetes has a number of features. It can be thought of as:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"a container platform"),Object(r.b)("li",{parentName:"ul"},"a microservices platform"),Object(r.b)("li",{parentName:"ul"},"a portable cloud platform and a lot more.")),Object(r.b)("p",null,"Kubernetes provides a ",Object(r.b)("strong",{parentName:"p"},"container-centric")," management environment. It orchestrates computing, networking, and storage infrastructure on behalf of user workloads. This provides much of the simplicity of Platform as a Service ","(","PaaS",")"," with the flexibility of Infrastructure as a Service ","(","IaaS",")",", and enables portability across infrastructure providers."),Object(r.b)("h2",{id:"what-kubernetes-is-not"},"What Kubernetes is not"),Object(r.b)("p",null,"Kubernetes is not a traditional, all-inclusive PaaS ","(","Platform as a Service",")"," system. Since Kubernetes operates at the container level rather than at the hardware level, it provides some generally applicable features common to PaaS offerings, such as deployment, scaling, load balancing, logging, and monitoring. However, Kubernetes is not monolithic, and these default solutions are optional and pluggable. Kubernetes provides the building blocks for building developer platforms, but preserves user choice and flexibility where it is important. Kubernetes:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Does not limit the types of applications supported. Kubernetes aims to support an extremely diverse variety of workloads, including stateless, stateful, and data-processing workloads. If an application can run in a container, it should run great on Kubernetes."),Object(r.b)("li",{parentName:"ul"},"Does not deploy source code and does not build your application. Continuous Integration, Delivery, and Deployment ","(","CI/CD",")"," workflows are determined by organization cultures and preferences as well as technical requirements."),Object(r.b)("li",{parentName:"ul"},"Does not provide application-level services, such as middleware ","(","e.g., message buses",")",", data-processing frameworks ","(","for example, Spark",")",", databases ","(","e.g., mysql",")",", caches, nor cluster storage systems ","(","e.g., Ceph",")"," as built-in services. Such components can run on Kubernetes, and/or can be accessed by applications running on Kubernetes through portable mechanisms, such as the Open Service Broker."),Object(r.b)("li",{parentName:"ul"},"Does not dictate logging, monitoring, or alerting solutions. It provides some integrations as proof of concept, and mechanisms to collect and export metrics."),Object(r.b)("li",{parentName:"ul"},"Does not provide nor mandate a configuration language/system ","(","e.g., ",Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"https://github.com/google/jsonnet"}),"jsonnet"),")",". It provides a declarative API that may be targeted by arbitrary forms of declarative specifications."),Object(r.b)("li",{parentName:"ul"},"Does not provide nor adopt any comprehensive machine configuration, maintenance, management, or self-healing systems.")),Object(r.b)("p",null,"Additionally, Kubernetes is not a mere ",Object(r.b)("em",{parentName:"p"},"orchestration system"),". In fact, it eliminates the need for orchestration. The technical definition of ",Object(r.b)("em",{parentName:"p"},"orchestration")," is execution of a defined workflow: first do A, then B, then C. In contrast, Kubernetes is comprised of a set of independent, composable control processes that continuously drive the current state towards the provided desired state. It shouldn\u2019t matter how you get from A to C. Centralized control is also not required. This results in a system that is easier to use and more powerful, robust, resilient, and extensible."),Object(r.b)("h2",{id:"why-containers"},"Why containers"),Object(r.b)("p",null,"Looking for reasons why you should be using containers"),Object(r.b)("img",{alt:"docker vs vm",src:Object(i.a)("img/docker-vs-vm.png")}),Object(r.b)("p",null,"The ",Object(r.b)("em",{parentName:"p"},"Old Way")," to deploy applications was to install the applications on a host using the operating-system package manager. This had the disadvantage of entangling the applications\u2019 executables, configuration, libraries, and lifecycles with each other and with the host OS. One could build immutable virtual-machine images in order to achieve predictable rollouts and rollbacks, but VMs are heavyweight and non-portable. The ",Object(r.b)("em",{parentName:"p"},"New Way")," is to deploy containers based on operating-system-level virtualization rather than hardware virtualization. These containers are isolated from each other and from the host: they have their own filesystems, they can\u2019t see each others\u2019 processes, and their computational resource usage can be bounded. They are easier to build than VMs, and because they are decoupled from the underlying infrastructure and from the host filesystem, they are portable across clouds and OS distributions. Because containers are small and fast, one application can be packed in each container image. This one-to-one application-to-image relationship unlocks the full benefits of containers. With containers, immutable container images can be created at build/release time rather than deployment time, since each application doesn\u2019t need to be composed with the rest of the application stack, nor married to the production infrastructure environment. Generating container images at build/release time enables a consistent environment to be carried from development into production. Similarly, containers are vastly more transparent than VMs, which facilitates monitoring and management. This is especially true when the containers\u2019 process lifecycles are managed by the infrastructure rather than hidden by a process supervisor inside the container. Finally, with a single application per container, managing the containers becomes tantamount to managing deployment of the application. Summary of container benefits:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Agile application creation and deployment"),": Increased ease and efficiency of container image creation compared to VM image use."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Continuous development, integration, and deployment"),": Provides for reliable and frequent container image build and deployment with quick and easy rollbacks ","(","due to image immutability",")","."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Dev and Ops separation of concerns"),": Create application container images at build/release time rather than deployment time, thereby decoupling applications from infrastructure."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Observability")," Not only surfaces OS-level information and metrics, but also application health and other signals."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Environmental consistency across development, testing, and production"),": Runs the same on a laptop as it does in the cloud."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Cloud and OS distribution portability"),": Runs on Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine, and anywhere else."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Application-centric management"),": Raises the level of abstraction from running an OS on virtual hardware to running an application on an OS using logical resources."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Loosely coupled, distributed, elastic, liberated")," ",Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"https://martinfowler.com/articles/microservices.html"}),Object(r.b)("strong",{parentName:"a"},"micro-services")),": Applications are broken into smaller, independent pieces and can be deployed and managed dynamically \u2013 not a monolithic stack running on one big single-purpose machine."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Resource isolation"),": Predictable application performance."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Resource utilization"),": High efficiency and density.")),Object(r.b)("h2",{id:"kubernetes-architecture"},"Kubernetes architecture"),Object(r.b)("p",null,"At its core, Kubernetes is a data store ","(","etcd",")",". The declarative model is stored in the data store as objects, that means when you say I want 5 instances of a container then that request is stored into the data store. This information change is watched and delegated to Controllers to take action. Controllers then react to the model and attempt to take action to achieve the desired state. The power of Kubernetes is in its simplistic model. As shown, API server is a simple HTTP server handling create/read/update/delete","(","CRUD",")"," operations on the data store. Then the controller picks up the change you wanted and makes that happen. Controllers are responsible for instantiating the actual resource represented by any Kubernetes resource. These actual resources are what your application needs to allow it to run successful"),Object(r.b)("img",{alt:"Kubernetes Flow",src:Object(i.a)("img/k8s-flow.png")}),Object(r.b)("h3",{id:"kubernetes-resource-model"},"Kubernetes resource model"),Object(r.b)("p",null,"Kubernetes Infrastructure defines a resource for every purpose. Each resource is monitored and processed by a controller. When you define your application, it contains a collection of these resources. This collection will then be read by Controllers to build your applications actual backing instances. Some of resources that you may work with are listed below for your reference, for a full list you should go to ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/"}),"https://kubernetes.io/docs/concepts/"),". In this class we will only use a few of them, like Pod, Deployment, etc."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Config Maps holds configuration data for pods to consume."),Object(r.b)("li",{parentName:"ul"},"Daemon Sets ensure that each node in the cluster runs this Pod"),Object(r.b)("li",{parentName:"ul"},"Deployments defines a desired state of a deployment object"),Object(r.b)("li",{parentName:"ul"},"Events provides lifecycle events on Pods and other deployment objects"),Object(r.b)("li",{parentName:"ul"},"Endpoints allows a inbound connections to reach the cluster services"),Object(r.b)("li",{parentName:"ul"},"Ingress is a collection of rules that allow inbound connections to reach the cluster services"),Object(r.b)("li",{parentName:"ul"},"Jobs creates one or more pods and as they complete successfully the job is marked as completed."),Object(r.b)("li",{parentName:"ul"},"Node is a worker machine in Kubernetes"),Object(r.b)("li",{parentName:"ul"},"Namespaces are multiple virtual clusters backed by the same physical cluster"),Object(r.b)("li",{parentName:"ul"},"Pods are the smallest deployable units of computing that can be created and managed in Kubernetes"),Object(r.b)("li",{parentName:"ul"},"Persistent Volumes provides an API for users and administrators that abstracts details of how storage is provided from how it is consumed"),Object(r.b)("li",{parentName:"ul"},"Replica Sets ensures that a specified number of pod replicas are running at any given time"),Object(r.b)("li",{parentName:"ul"},"Secrets are intended to hold sensitive information, such as passwords, OAuth tokens, and ssh keys"),Object(r.b)("li",{parentName:"ul"},"Service Accounts provides an identity for processes that run in a Pod"),Object(r.b)("li",{parentName:"ul"},"Services is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a micro-service."),Object(r.b)("li",{parentName:"ul"},"Stateful Sets is the workload API object used to manage stateful applications."),Object(r.b)("li",{parentName:"ul"},"and more...")),Object(r.b)("img",{alt:"Kubernetes Flow",src:Object(i.a)("img/architecture.png")}),Object(r.b)("h3",{id:"hardware"},"Hardware"),Object(r.b)("h4",{id:"node"},"Node"),Object(r.b)("img",{alt:"Kubernetes Flow",src:Object(i.a)("img/compute.png")}),Object(r.b)("p",null,"A ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/architecture/nodes/"}),"node")," is the smallest unit of computing hardware in Kubernetes. It is a representation of a single machine in your cluster. In most production systems, a node will likely be either a physical machine in a datacenter, or virtual machine hosted on a cloud provider like ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://cloud.google.com/"}),"Google Cloud Platform"),". Don\u2019t let conventions limit you, however; in theory, you can make a node out of ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://twitter.com/jkrippy/status/932800484703862784"}),"almost")," ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://blog.hypriot.com/post/setup-kubernetes-raspberry-pi-cluster/"}),"anything"),". Thinking of a machine as a \u201cnode\u201d allows us to insert a layer of abstraction. Now, instead of worrying about the unique characteristics of any individual machine, we can instead simply view each machine as a set of CPU and RAM resources that can be utilized. In this way, any machine can substitute any other machine in a Kubernetes cluster."),Object(r.b)("h4",{id:"the-cluster"},"The Cluster"),Object(r.b)("img",{alt:"Kubernetes Flow",src:Object(i.a)("img/nodes.png")}),Object(r.b)("p",null,"Although working with individual nodes can be useful, it\u2019s not the Kubernetes way. In general, you should think about the cluster as a whole, instead of worrying about the state of individual nodes. In Kubernetes, nodes pool together their resources to form a more powerful machine. When you deploy programs onto the cluster, it intelligently handles distributing work to the individual nodes for you. If any nodes are added or removed, the cluster will shift around work as necessary. It shouldn\u2019t matter to the program, or the programmer, which individual machines are actually running the code. If this kind of hivemind-like system reminds you of the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"http://memory-alpha.wikia.com/wiki/Borg"}),"Borg from Star Trek"),", you\u2019re not alone; \u201cBorg\u201d is the name for the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"http://blog.kubernetes.io/2015/04/borg-predecessor-to-kubernetes.html"}),"internal Google project"),"Kubernetes was based on."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Persistent Volumes")," Because programs running on your cluster aren\u2019t guaranteed to run on a specific node, data can\u2019t be saved to any arbitrary place in the file system. If a program tries to save data to a file for later, but is then relocated onto a new node, the file will no longer be where the program expects it to be. For this reason, the traditional local storage associated to each node is treated as a temporary cache to hold programs, but any data saved locally can not be expected to persist"),Object(r.b)("p",null,Object(r.b)("img",Object(n.a)({parentName:"p"},{src:"https://cdn-images-1.medium.com/max/1200/1*kF57zE9a5YCzhILHdmuRvQ.png",alt:null}))),Object(r.b)("p",null,"To store data permanently, Kubernetes uses ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/"}),"Persistent Volumes"),". While the CPU and RAM resources of all nodes are effectively pooled and managed by the cluster, persistent file storage is not. Instead, local or cloud drives can be attached to the cluster as a Persistent Volume. This can be thought of as plugging an external hard drive in to the cluster. Persistent Volumes provide a file system that can be mounted to the cluster, without being associated with any particular node."),Object(r.b)("h3",{id:"software"},"Software"),Object(r.b)("h4",{id:"containers"},"Containers"),Object(r.b)("p",null,Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://camo.githubusercontent.com/29690b72d0d0be8349cf6965fbc67395bb050535/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a494c696e7a7a4d646e44356f513654753262664267512e706e67"}),Object(r.b)("img",Object(n.a)({parentName:"a"},{src:"https://camo.githubusercontent.com/29690b72d0d0be8349cf6965fbc67395bb050535/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a494c696e7a7a4d646e44356f513654753262664267512e706e67",alt:null}))),Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://camo.githubusercontent.com/b1285eef90c7a9f60cd200abe32af08b8710424a/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323030302f312a494c696e7a7a4d646e44356f513654753262664267512e706e67"}),Object(r.b)("img",Object(n.a)({parentName:"a"},{src:"https://camo.githubusercontent.com/b1285eef90c7a9f60cd200abe32af08b8710424a/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323030302f312a494c696e7a7a4d646e44356f513654753262664267512e706e67",alt:null})))),Object(r.b)("p",null,"Programs running on Kubernetes are packaged as ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://www.docker.com/what-container"}),"Linux containers"),". Containers are a widely accepted standard, so there are already many ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://hub.docker.com/explore/"}),"pre-built images")," that can be deployed on Kubernetes. Containerization allows you to create self-contained Linux execution environments. Any program and all its dependencies can be bundled up into a single file and then shared on the internet. Anyone can download the container and deploy it on their infrastructure with very little setup required. Creating a container can be done programmatically, allowing powerful ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"http://blog.sonatype.com/achieving-ci/cd-with-kubernetes"}),"CI and CD")," pipelines to be formed. Multiple programs can be added into a single container, but you should limit yourself to one process per container if at all possible. It\u2019s better to have many small containers than one large one. If each container has a tight focus, updates are easier to deploy and issues are easier to diagnose."),Object(r.b)("h4",{id:"pod"},"Pod"),Object(r.b)("p",null,Object(r.b)("img",Object(n.a)({parentName:"p"},{src:"https://cdn-images-1.medium.com/max/1600/1*8OD0MgDNu3Csq0tGpS8Obg.png",alt:null}))),Object(r.b)("p",null,"Unlike other systems you may have used in the past, Kubernetes doesn\u2019t run containers directly; instead it wraps one or more containers into a higher-level structure called a ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/workloads/pods/pod/"}),"pod"),". Any containers in the same pod will share the same resources and local network. Containers can easily communicate with other containers in the same pod as though they were on the same machine while maintaining a degree of isolation from others. Pods are used as the unit of replication in Kubernetes. If your application becomes too popular and a single pod instance can\u2019t carry the load, Kubernetes can be configured to deploy new replicas of your pod to the cluster as necessary. Even when not under heavy load, it is standard to have multiple copies of a pod running at any time in a production system to allow load balancing and failure resistance. Pods can hold multiple containers, but you should limit yourself when possible. Because pods are scaled up and down as a unit, all containers in a pod must scale together, regardless of their individual needs. This leads to wasted resources and an expensive bill. To resolve this, pods should remain as small as possible, typically holding only a main process and its tightly-coupled helper containers ","(","these helper containers are typically referred to as \u201cside-cars\u201d",")","."),Object(r.b)("h4",{id:"deployment"},"Deployment"),Object(r.b)("p",null,Object(r.b)("img",Object(n.a)({parentName:"p"},{src:"https://cdn-images-1.medium.com/max/1600/1*iTAVk3glVD95hb-X3HiCKg.png",alt:null}))),Object(r.b)("p",null,"Although pods are the basic unit of computation in Kubernetes, they are not typically directly launched on a cluster. Instead, pods are usually managed by one more layer of abstraction: the ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/"}),"deployment"),". A deployment\u2019s primary purpose is to declare how many replicas of a pod should be running at a time. When a deployment is added to the cluster, it will automatically spin up the requested number of pods, and then monitor them. If a pod dies, the deployment will automatically re-create it. Using a deployment, you don\u2019t have to deal with pods manually. You can just declare the desired state of the system, and it will be managed for you automatically."),Object(r.b)("h4",{id:"ingress"},"Ingress"),Object(r.b)("p",null,Object(r.b)("img",Object(n.a)({parentName:"p"},{src:"https://cdn-images-1.medium.com/max/1600/1*tBJ-_g4Mk5OkfzLEHrRsRw.png",alt:null}))),Object(r.b)("p",null,"Using the concepts described above, you can create a cluster of nodes, and launch deployments of pods onto the cluster. There is one last problem to solve, however: allowing external traffic to your application. By default, Kubernetes provides isolation between pods and the outside world. If you want to communicate with a service running in a pod, you have to open up a channel for communication. This is referred to as ingress. There are multiple ways to add ingress to your cluster. The most common ways are by adding either an ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/services-networking/ingress/"}),"Ingress")," controller, or a ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/"}),"LoadBalancer"),". The exact tradeoffs between these two options are out of scope for this post, but you must be aware that ingress is something you need to handle before you can experiment with Kubernetes."),Object(r.b)("h2",{id:"deployment-primitives"},"Deployment Primitives"),Object(r.b)("p",null,"Kubernetes has many things"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"NAME                              SHORTNAMES   APIGROUP                       NAMESPACED   KIND\nbindings                                                                      true         Binding\ncomponentstatuses                 cs                                          false        ComponentStatus\nconfigmaps                        cm                                          true         ConfigMap\nendpoints                         ep                                          true         Endpoints\nevents                            ev                                          true         Event\nlimitranges                       limits                                      true         LimitRange\nnamespaces                        ns                                          false        Namespace\nnodes                             no                                          false        Node\npersistentvolumeclaims            pvc                                         true         PersistentVolumeClaim\npersistentvolumes                 pv                                          false        PersistentVolume\npods                              po                                          true         Pod\npodtemplates                                                                  true         PodTemplate\nreplicationcontrollers            rc                                          true         ReplicationController\nresourcequotas                    quota                                       true         ResourceQuota\nsecrets                                                                       true         Secret\nserviceaccounts                   sa                                          true         ServiceAccount\nservices                          svc                                         true         Service\ninitializerconfigurations                      admissionregistration.k8s.io   false        InitializerConfiguration\nmutatingwebhookconfigurations                  admissionregistration.k8s.io   false        MutatingWebhookConfiguration\nvalidatingwebhookconfigurations                admissionregistration.k8s.io   false        ValidatingWebhookConfiguration\ncustomresourcedefinitions         crd,crds     apiextensions.k8s.io           false        CustomResourceDefinition\napiservices                                    apiregistration.k8s.io         false        APIService\ncontrollerrevisions                            apps                           true         ControllerRevision\ndaemonsets                        ds           apps                           true         DaemonSet\ndeployments                       deploy       apps                           true         Deployment\nreplicasets                       rs           apps                           true         ReplicaSet\nstatefulsets                      sts          apps                           true         StatefulSet\nmeshpolicies                                   authentication.istio.io        false        MeshPolicy\npolicies                                       authentication.istio.io        true         Policy\ntokenreviews                                   authentication.k8s.io          false        TokenReview\nlocalsubjectaccessreviews                      authorization.k8s.io           true         LocalSubjectAccessReview\nselfsubjectaccessreviews                       authorization.k8s.io           false        SelfSubjectAccessReview\nselfsubjectrulesreviews                        authorization.k8s.io           false        SelfSubjectRulesReview\nsubjectaccessreviews                           authorization.k8s.io           false        SubjectAccessReview\nhorizontalpodautoscalers          hpa          autoscaling                    true         HorizontalPodAutoscaler\ncronjobs                          cj           batch                          true         CronJob\njobs                                           batch                          true         Job\ncertificatesigningrequests        csr          certificates.k8s.io            false        CertificateSigningRequest\ncertificates                      cert,certs   certmanager.k8s.io             true         Certificate\nchallenges                                     certmanager.k8s.io             true         Challenge\nclusterissuers                                 certmanager.k8s.io             false        ClusterIssuer\nissuers                                        certmanager.k8s.io             true         Issuer\norders                                         certmanager.k8s.io             true         Order\nleases                                         coordination.k8s.io            true         Lease\nevents                            ev           events.k8s.io                  true         Event\ndaemonsets                        ds           extensions                     true         DaemonSet\ndeployments                       deploy       extensions                     true         Deployment\ningresses                         ing          extensions                     true         Ingress\nnetworkpolicies                   netpol       extensions                     true         NetworkPolicy\npodsecuritypolicies               psp          extensions                     false        PodSecurityPolicy\nreplicasets                       rs           extensions                     true         ReplicaSet\nnodes                                          metrics.k8s.io                 false        NodeMetrics\npods                                           metrics.k8s.io                 true         PodMetrics\nnetworkpolicies                   netpol       networking.k8s.io              true         NetworkPolicy\npoddisruptionbudgets              pdb          policy                         true         PodDisruptionBudget\npodsecuritypolicies               psp          policy                         false        PodSecurityPolicy\nclusterrolebindings                            rbac.authorization.k8s.io      false        ClusterRoleBinding\nclusterroles                                   rbac.authorization.k8s.io      false        ClusterRole\nrolebindings                                   rbac.authorization.k8s.io      true         RoleBinding\nroles                                          rbac.authorization.k8s.io      true         Role\npriorityclasses                   pc           scheduling.k8s.io              false        PriorityClass\nstorageclasses                    sc           storage.k8s.io                 false        StorageClass\nvolumeattachments                              storage.k8s.io                 false        VolumeAttachment\n")),Object(r.b)("p",null,"To get our app to run on K8S we don't need to know all of them. At the bare minimum we need to deal with 3 of these. Pods, Deployments and Services."),Object(r.b)("h3",{id:"pods"},"Pods"),Object(r.b)("p",null,"Pods is the smallest unit in kubernetes. Each pod has to have atleast one container. But can have more. In some advanced kubernetes setup there are more that one container. Sidecar container, init container etc. "),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"apiVersion: v1\nkind: Pod\nmetadata:\n  name: pod-example\nspec:\n  containers:\n  - name: ubuntu\n    image: ubuntu:trusty\n")),Object(r.b)("p",null,"This is the most minimal pod you can create. "),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Field"),Object(r.b)("th",Object(n.a)({parentName:"tr"},{align:"left"}),"Description"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"apiVersion")," string"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: ",Object(r.b)("a",Object(n.a)({parentName:"td"},{href:"https://git.k8s.io/community/contributors/devel/api-conventions.md%5C#resources"}),"https://git.k8s.io/community/contributors/devel/api-conventions.md\\#resources"))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"kind")," string"),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: ",Object(r.b)("a",Object(n.a)({parentName:"td"},{href:"https://git.k8s.io/community/contributors/devel/api-conventions.md%5C#types-kinds"}),"https://git.k8s.io/community/contributors/devel/api-conventions.md\\#types-kinds"))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"metadata")," ",Object(r.b)("a",Object(n.a)({parentName:"td"},{href:"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#objectmeta-v1-meta"}),"ObjectMeta")),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Standard object's metadata. More info: ",Object(r.b)("a",Object(n.a)({parentName:"td"},{href:"https://git.k8s.io/community/contributors/devel/api-conventions.md%5C#metadata"}),"https://git.k8s.io/community/contributors/devel/api-conventions.md\\#metadata"))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),Object(r.b)("inlineCode",{parentName:"td"},"spec")," ",Object(r.b)("a",Object(n.a)({parentName:"td"},{href:"https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#podspec-v1-core"}),"PodSpec")),Object(r.b)("td",Object(n.a)({parentName:"tr"},{align:"left"}),"Specification of the desired behavior of the pod. More info: ",Object(r.b)("a",Object(n.a)({parentName:"td"},{href:"https://git.k8s.io/community/contributors/devel/api-conventions.md%5C#spec-and-status"}),"https://git.k8s.io/community/contributors/devel/api-conventions.md\\#spec-and-status"))))),Object(r.b)("p",null,"In k8s we should never create a pod this way. Because pods by itself can not self restart or scale if needed."),Object(r.b)("p",null,"For that we use a replicaset or deployment."),Object(r.b)("h3",{id:"deployment-1"},"Deployment"),Object(r.b)("p",null,"A ",Object(r.b)("em",{parentName:"p"},"Deployment")," controller provides declarative updates for ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/workloads/pods/pod/"}),"Pods")," and ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/"}),"ReplicaSets"),"."),Object(r.b)("p",null,"You describe a ",Object(r.b)("em",{parentName:"p"},"desired state")," in a Deployment object, and the Deployment controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments."),Object(r.b)("p",null,"The quick and dirty way to create a deployment is to use the run command."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"kubectl run nginx --image=nginx:1.10 --replicas=3\n")),Object(r.b)("p",null,"But this is not preferred because its not reproducible. We should use a yaml file and check it in version control. "),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  # Unique key of the Deployment instance\n  name: deployment-example\nspec:\n  # 3 Pods should exist at all times.\n  replicas: 3\n  template:\n    metadata:\n      labels:\n        # Apply this label to pods and default\n        # the Deployment label selector to this value\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        # Run this image\n        image: nginx:1.10\n")),Object(r.b)("p",null,"The pod spec is embedded in the deployment under template."),Object(r.b)("p",null,"Finally we need a way to make the app available to the world. We use a service for that."),Object(r.b)("h3",{id:"service"},"Service"),Object(r.b)("p",null,"Kubernetes ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/workloads/pods/pod/"}),Object(r.b)("inlineCode",{parentName:"a"},"Pods"))," are mortal. They are born and when they die, they are not resurrected. ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/"}),Object(r.b)("inlineCode",{parentName:"a"},"ReplicaSets"))," in particular create and destroy ",Object(r.b)("inlineCode",{parentName:"p"},"Pods")," dynamically ","(","e.g. when scaling out or in",")",". While each ",Object(r.b)("inlineCode",{parentName:"p"},"Pod")," gets its own IP address, even those IP addresses cannot be relied upon to be stable over time. This leads to a problem: if some set of ",Object(r.b)("inlineCode",{parentName:"p"},"Pods")," ","(","let\u2019s call them backends",")"," provides functionality to other ",Object(r.b)("inlineCode",{parentName:"p"},"Pods")," ","(","let\u2019s call them frontends",")"," inside the Kubernetes cluster, how do those frontends find out and keep track of which backends are in that set?"),Object(r.b)("p",null,"Enter ",Object(r.b)("inlineCode",{parentName:"p"},"Services"),"."),Object(r.b)("p",null,"A Kubernetes ",Object(r.b)("inlineCode",{parentName:"p"},"Service")," is an abstraction which defines a logical set of ",Object(r.b)("inlineCode",{parentName:"p"},"Pods")," and a policy by which to access them - sometimes called a micro-service. The set of ",Object(r.b)("inlineCode",{parentName:"p"},"Pods")," targeted by a ",Object(r.b)("inlineCode",{parentName:"p"},"Service")," is ","(","usually",")"," determined by a ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors"}),Object(r.b)("inlineCode",{parentName:"a"},"Label Selector"))," ","(","see below for why you might want a ",Object(r.b)("inlineCode",{parentName:"p"},"Service")," without a selector",")","."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{className:"language-text"}),"kind: Service\napiVersion: v1\nmetadata:\n  # Unique key of the Service instance\n  name: service-example\nspec:\n  ports:\n    # Accept traffic sent to port 80\n    - name: http\n      port: 80\n      targetPort: 80\n  selector:\n    # this label selector\n    app: nginx\n")),Object(r.b)("p",null,"There are few types of services out there."),Object(r.b)("p",null,"For some parts of your application ","(","e.g. frontends",")"," you may want to expose a Service onto an external ","(","outside of your cluster",")"," IP address."),Object(r.b)("p",null,"Kubernetes ",Object(r.b)("inlineCode",{parentName:"p"},"ServiceTypes")," allow you to specify what kind of service you want. The default is ",Object(r.b)("inlineCode",{parentName:"p"},"ClusterIP"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Type")," values and their behaviors are:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"ClusterIP"),": Exposes the service on a cluster-internal IP. Choosing this value makes the service only reachable from within the cluster. This is the default ",Object(r.b)("inlineCode",{parentName:"li"},"ServiceType"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"https://kubernetes.io/docs/concepts/services-networking/service/#nodeport"}),Object(r.b)("inlineCode",{parentName:"a"},"NodePort")),": Exposes the service on each Node\u2019s IP at a static port ","(","the ",Object(r.b)("inlineCode",{parentName:"li"},"NodePort"),")",". A ",Object(r.b)("inlineCode",{parentName:"li"},"ClusterIP")," service, to which the ",Object(r.b)("inlineCode",{parentName:"li"},"NodePort")," service will route, is automatically created. You\u2019ll be able to contact the ",Object(r.b)("inlineCode",{parentName:"li"},"NodePort")," service, from outside the cluster, by requesting ",Object(r.b)("inlineCode",{parentName:"li"},"<NodeIP>:<NodePort>"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer"}),Object(r.b)("inlineCode",{parentName:"a"},"LoadBalancer")),": Exposes the service externally using a cloud provider\u2019s load balancer. ",Object(r.b)("inlineCode",{parentName:"li"},"NodePort")," and ",Object(r.b)("inlineCode",{parentName:"li"},"ClusterIP")," services, to which the external load balancer will route, are automatically created."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("a",Object(n.a)({parentName:"li"},{href:"https://kubernetes.io/docs/concepts/services-networking/service/#externalname"}),Object(r.b)("inlineCode",{parentName:"a"},"ExternalName")),": Maps the service to the contents of the ",Object(r.b)("inlineCode",{parentName:"li"},"externalName")," field ","(","e.g. ",Object(r.b)("inlineCode",{parentName:"li"},"foo.bar.example.com"),")",", by returning a ",Object(r.b)("inlineCode",{parentName:"li"},"CNAME")," record with its value. No proxying of any kind is set up. This requires version 1.7 or higher of ",Object(r.b)("inlineCode",{parentName:"li"},"kube-dns"),".")),Object(r.b)("p",null,"ClusterIP is cluster internal. We will see both ClusterIP and LoadBalancer in depth in a second."))}u.isMDXComponent=!0},81:function(e,t,a){"use strict";a.d(t,"a",(function(){return u})),a.d(t,"b",(function(){return m}));var n=a(0),o=a.n(n);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=o.a.createContext({}),d=function(e){var t=o.a.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},u=function(e){var t=d(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},p=o.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,r=e.originalType,i=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=d(a),p=n,m=u["".concat(i,".").concat(p)]||u[p]||b[p]||r;return a?o.a.createElement(m,s(s({ref:t},l),{},{components:a})):o.a.createElement(m,s({ref:t},l))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var r=a.length,i=new Array(r);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:n,i[1]=s;for(var l=2;l<r;l++)i[l]=a[l];return o.a.createElement.apply(null,i)}return o.a.createElement.apply(null,a)}p.displayName="MDXCreateElement"},82:function(e,t,a){"use strict";var n=a(0),o=a(22);t.a=function(){var e=Object(n.useContext)(o.a);if(null===e)throw new Error("Docusaurus context not provided");return e}},84:function(e,t,a){"use strict";a.d(t,"b",(function(){return r})),a.d(t,"a",(function(){return i}));var n=a(82),o=a(86);function r(){var e=Object(n.a)().siteConfig,t=(e=void 0===e?{}:e).baseUrl,a=void 0===t?"/":t,r=e.url;return{withBaseUrl:function(e,t){return function(e,t,a,n){var r=void 0===n?{}:n,i=r.forcePrependBaseUrl,s=void 0!==i&&i,c=r.absolute,l=void 0!==c&&c;if(!a)return a;if(a.startsWith("#"))return a;if(Object(o.b)(a))return a;if(s)return t+a;var d=a.startsWith(t)?a:t+a.replace(/^\//,"");return l?e+d:d}(r,a,e,t)}}}function i(e,t){return void 0===t&&(t={}),(0,r().withBaseUrl)(e,t)}},86:function(e,t,a){"use strict";function n(e){return!0===/^(\w*:|\/\/)/.test(e)}function o(e){return void 0!==e&&!n(e)}a.d(t,"b",(function(){return n})),a.d(t,"a",(function(){return o}))}}]);