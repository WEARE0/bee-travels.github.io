<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-alpha.65">
<title data-react-helmet="true">Kubernetes | Bee Travels</title><meta data-react-helmet="true" name="docsearch:version" content="current,latest"><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Kubernetes | Bee Travels"><meta data-react-helmet="true" name="description" content="Developers want to build applications. So how do we get our app out there in the real world? How do we make sure our app runs everywhere like it runs on our local dev environment?"><meta data-react-helmet="true" property="og:description" content="Developers want to build applications. So how do we get our app out there in the real world? How do we make sure our app runs everywhere like it runs on our local dev environment?"><meta data-react-helmet="true" property="og:url" content="https://bee-travels.github.io/docs/kube"><link data-react-helmet="true" rel="shortcut icon" href="/img/faviconBee.ico"><link data-react-helmet="true" rel="canonical" href="https://bee-travels.github.io/docs/kube"><link rel="stylesheet" href="/styles.e4f86489.css">
<link rel="preload" href="/styles.b8ff35c3.js" as="script">
<link rel="preload" href="/runtime~main.f20a1611.js" as="script">
<link rel="preload" href="/main.3c1da133.js" as="script">
<link rel="preload" href="/1.2594eb98.js" as="script">
<link rel="preload" href="/2.60cd53ed.js" as="script">
<link rel="preload" href="/23.4bf89ce8.js" as="script">
<link rel="preload" href="/24.ce4b8b15.js" as="script">
<link rel="preload" href="/935f2afb.60f6c2a3.js" as="script">
<link rel="preload" href="/17896441.787198e7.js" as="script">
<link rel="preload" href="/008e8819.39eae513.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/logo.svg" alt="Bee-Travels"><strong class="navbar__title">Bee Travels</strong></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/">Docs</a><a class="navbar__item navbar__link" href="/workshop">Workshop</a></div><div class="navbar__items navbar__items--right"><a href="https://developer.ibm.com/?s=microservices" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">IBM Developer</a><a href="https://github.com/bee-travels" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link" aria-label="GitHub repository"></a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">🌜</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">🌞</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/"><img class="navbar__logo" src="/img/logo.svg" alt="Bee-Travels"><strong class="navbar__title">Bee Travels</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link navbar__link--active" href="/docs/">Docs</a></li><li class="menu__list-item"><a class="menu__link" href="/workshop">Workshop</a></li><li class="menu__list-item"><a href="https://developer.ibm.com/?s=microservices" target="_blank" rel="noopener noreferrer" class="menu__link">IBM Developer</a></li><li class="menu__list-item"><a href="https://github.com/bee-travels" target="_blank" rel="noopener noreferrer" class="menu__link header-github-link" aria-label="GitHub repository"></a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/docs/">Introduction</a></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Microservices</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/about">About Microservices</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/designing">Designing Microservices</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Runtime</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/node">Node.js</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/python">Python</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Deployment</a><ul class="menu__list"><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/docs/kube">Kubernetes</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/openshift">Openshift</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/istioabout">Istio</a></li><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/docs/knativeabout">Knative</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Life Cycle</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/docs/tdd">Test Driven Development</a></li></ul></li><li class="menu__list-item"><a class="menu__link" href="/docs/techtalks">Tech Talks</a></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Kubernetes</h1></header><div class="markdown"><p>Developers want to build applications. So how do we get our app out there in the real world? How do we make sure our app runs everywhere like it runs on our local dev environment?</p><p>That’s where Docker came in, however, Docker was not enough to run our application at scale. Kubernetes (<a href="https://kubernetes.io/" target="_blank" rel="noopener noreferrer">https://kubernetes.io/</a>) helps us scale our application and gives us many other benefits. Nevertheless, all of these new tools comes with their own steep learning curve.</p><p>We all probably heard of Kubernetes. If we did not hear about it yet we will.</p><p><em><strong>Kubernetes is a portable, extensible open-source platform for managing containerized workloads and services, that facilitates both declarative configuration and automation. It has a large, rapidly growing ecosystem. Kubernetes services, support, and tools are widely available.</strong></em></p><p>Thats the definition of Kubernetes from the Kubernetes official documentation.</p><p>Honestly that is not super clear what Kubernetes is from that documentation. And the reason it is not clear is because Kubernetes is many things. Its a container platform, a microservices platform a portable cloud platform and so much more.</p><p>As Kelsey Hightower so very aptly put</p><img alt="Kelsey Tweets about K8s" src="/img/kelsey.png"><p>Kubernetes is an abstraction on the infrastructure that helps automate many important but mundane and labor intensive work that was being done by many teams across the industry over and over and over again. K8s (Short for Kubernetes) gives a great starting point for most people and gives a way to standardize best practices across the industry. What most people don’t even realize is that K8s is making the skills of platform and system engineers portable across industries and companies as well as making it easy for companies to find talent.</p><p>I still don’t think I am anywhere closer to defining what K8s actually is. I don’t think there is a short and concise definition for it. Instead lets talk about how K8s came to be, what it is made of and what problems it solves and maybe we will have a clearer view about the purpose of K8s.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="why-do-i-need-kubernetes-and-what-can-it-do"></a>Why do I need Kubernetes and what can it do?<a aria-hidden="true" tabindex="-1" class="hash-link" href="#why-do-i-need-kubernetes-and-what-can-it-do" title="Direct link to heading">#</a></h2><p>Kubernetes has a number of features. It can be thought of as:</p><ul><li>a container platform</li><li>a microservices platform</li><li>a portable cloud platform and a lot more.</li></ul><p>Kubernetes provides a <strong>container-centric</strong> management environment. It orchestrates computing, networking, and storage infrastructure on behalf of user workloads. This provides much of the simplicity of Platform as a Service (PaaS) with the flexibility of Infrastructure as a Service (IaaS), and enables portability across infrastructure providers.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="what-kubernetes-is-not"></a>What Kubernetes is not<a aria-hidden="true" tabindex="-1" class="hash-link" href="#what-kubernetes-is-not" title="Direct link to heading">#</a></h2><p>Kubernetes is not a traditional, all-inclusive PaaS (Platform as a Service) system. Since Kubernetes operates at the container level rather than at the hardware level, it provides some generally applicable features common to PaaS offerings, such as deployment, scaling, load balancing, logging, and monitoring. However, Kubernetes is not monolithic, and these default solutions are optional and pluggable. Kubernetes provides the building blocks for building developer platforms, but preserves user choice and flexibility where it is important. Kubernetes:</p><ul><li>Does not limit the types of applications supported. Kubernetes aims to support an extremely diverse variety of workloads, including stateless, stateful, and data-processing workloads. If an application can run in a container, it should run great on Kubernetes.</li><li>Does not deploy source code and does not build your application. Continuous Integration, Delivery, and Deployment (CI/CD) workflows are determined by organization cultures and preferences as well as technical requirements.</li><li>Does not provide application-level services, such as middleware (e.g., message buses), data-processing frameworks (for example, Spark), databases (e.g., mysql), caches, nor cluster storage systems (e.g., Ceph) as built-in services. Such components can run on Kubernetes, and/or can be accessed by applications running on Kubernetes through portable mechanisms, such as the Open Service Broker.</li><li>Does not dictate logging, monitoring, or alerting solutions. It provides some integrations as proof of concept, and mechanisms to collect and export metrics.</li><li>Does not provide nor mandate a configuration language/system (e.g., <a href="https://github.com/google/jsonnet" target="_blank" rel="noopener noreferrer">jsonnet</a>). It provides a declarative API that may be targeted by arbitrary forms of declarative specifications.</li><li>Does not provide nor adopt any comprehensive machine configuration, maintenance, management, or self-healing systems.</li></ul><p>Additionally, Kubernetes is not a mere <em>orchestration system</em>. In fact, it eliminates the need for orchestration. The technical definition of <em>orchestration</em> is execution of a defined workflow: first do A, then B, then C. In contrast, Kubernetes is comprised of a set of independent, composable control processes that continuously drive the current state towards the provided desired state. It shouldn’t matter how you get from A to C. Centralized control is also not required. This results in a system that is easier to use and more powerful, robust, resilient, and extensible.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="why-containers"></a>Why containers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#why-containers" title="Direct link to heading">#</a></h2><p>Looking for reasons why you should be using containers</p><img alt="docker vs vm" src="/img/docker-vs-vm.png"><p>The <em>Old Way</em> to deploy applications was to install the applications on a host using the operating-system package manager. This had the disadvantage of entangling the applications’ executables, configuration, libraries, and lifecycles with each other and with the host OS. One could build immutable virtual-machine images in order to achieve predictable rollouts and rollbacks, but VMs are heavyweight and non-portable. The <em>New Way</em> is to deploy containers based on operating-system-level virtualization rather than hardware virtualization. These containers are isolated from each other and from the host: they have their own filesystems, they can’t see each others’ processes, and their computational resource usage can be bounded. They are easier to build than VMs, and because they are decoupled from the underlying infrastructure and from the host filesystem, they are portable across clouds and OS distributions. Because containers are small and fast, one application can be packed in each container image. This one-to-one application-to-image relationship unlocks the full benefits of containers. With containers, immutable container images can be created at build/release time rather than deployment time, since each application doesn’t need to be composed with the rest of the application stack, nor married to the production infrastructure environment. Generating container images at build/release time enables a consistent environment to be carried from development into production. Similarly, containers are vastly more transparent than VMs, which facilitates monitoring and management. This is especially true when the containers’ process lifecycles are managed by the infrastructure rather than hidden by a process supervisor inside the container. Finally, with a single application per container, managing the containers becomes tantamount to managing deployment of the application. Summary of container benefits:</p><ul><li><strong>Agile application creation and deployment</strong>: Increased ease and efficiency of container image creation compared to VM image use.</li><li><strong>Continuous development, integration, and deployment</strong>: Provides for reliable and frequent container image build and deployment with quick and easy rollbacks (due to image immutability).</li><li><strong>Dev and Ops separation of concerns</strong>: Create application container images at build/release time rather than deployment time, thereby decoupling applications from infrastructure.</li><li><strong>Observability</strong> Not only surfaces OS-level information and metrics, but also application health and other signals.</li><li><strong>Environmental consistency across development, testing, and production</strong>: Runs the same on a laptop as it does in the cloud.</li><li><strong>Cloud and OS distribution portability</strong>: Runs on Ubuntu, RHEL, CoreOS, on-prem, Google Kubernetes Engine, and anywhere else.</li><li><strong>Application-centric management</strong>: Raises the level of abstraction from running an OS on virtual hardware to running an application on an OS using logical resources.</li><li><strong>Loosely coupled, distributed, elastic, liberated</strong> <a href="https://martinfowler.com/articles/microservices.html" target="_blank" rel="noopener noreferrer"><strong>micro-services</strong></a>: Applications are broken into smaller, independent pieces and can be deployed and managed dynamically – not a monolithic stack running on one big single-purpose machine.</li><li><strong>Resource isolation</strong>: Predictable application performance.</li><li><strong>Resource utilization</strong>: High efficiency and density.</li></ul><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kubernetes-architecture"></a>Kubernetes architecture<a aria-hidden="true" tabindex="-1" class="hash-link" href="#kubernetes-architecture" title="Direct link to heading">#</a></h2><p>At its core, Kubernetes is a data store (etcd). The declarative model is stored in the data store as objects, that means when you say I want 5 instances of a container then that request is stored into the data store. This information change is watched and delegated to Controllers to take action. Controllers then react to the model and attempt to take action to achieve the desired state. The power of Kubernetes is in its simplistic model. As shown, API server is a simple HTTP server handling create/read/update/delete(CRUD) operations on the data store. Then the controller picks up the change you wanted and makes that happen. Controllers are responsible for instantiating the actual resource represented by any Kubernetes resource. These actual resources are what your application needs to allow it to run successful</p><img alt="Kubernetes Flow" src="/img/k8s-flow.png"><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="kubernetes-resource-model"></a>Kubernetes resource model<a aria-hidden="true" tabindex="-1" class="hash-link" href="#kubernetes-resource-model" title="Direct link to heading">#</a></h3><p>Kubernetes Infrastructure defines a resource for every purpose. Each resource is monitored and processed by a controller. When you define your application, it contains a collection of these resources. This collection will then be read by Controllers to build your applications actual backing instances. Some of resources that you may work with are listed below for your reference, for a full list you should go to <a href="https://kubernetes.io/docs/concepts/" target="_blank" rel="noopener noreferrer">https://kubernetes.io/docs/concepts/</a>. In this class we will only use a few of them, like Pod, Deployment, etc.</p><ul><li>Config Maps holds configuration data for pods to consume.</li><li>Daemon Sets ensure that each node in the cluster runs this Pod</li><li>Deployments defines a desired state of a deployment object</li><li>Events provides lifecycle events on Pods and other deployment objects</li><li>Endpoints allows a inbound connections to reach the cluster services</li><li>Ingress is a collection of rules that allow inbound connections to reach the cluster services</li><li>Jobs creates one or more pods and as they complete successfully the job is marked as completed.</li><li>Node is a worker machine in Kubernetes</li><li>Namespaces are multiple virtual clusters backed by the same physical cluster</li><li>Pods are the smallest deployable units of computing that can be created and managed in Kubernetes</li><li>Persistent Volumes provides an API for users and administrators that abstracts details of how storage is provided from how it is consumed</li><li>Replica Sets ensures that a specified number of pod replicas are running at any given time</li><li>Secrets are intended to hold sensitive information, such as passwords, OAuth tokens, and ssh keys</li><li>Service Accounts provides an identity for processes that run in a Pod</li><li>Services is an abstraction which defines a logical set of Pods and a policy by which to access them - sometimes called a micro-service.</li><li>Stateful Sets is the workload API object used to manage stateful applications.</li><li>and more...</li></ul><img alt="Kubernetes Flow" src="/img/architecture.png"><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="hardware"></a>Hardware<a aria-hidden="true" tabindex="-1" class="hash-link" href="#hardware" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="node"></a>Node<a aria-hidden="true" tabindex="-1" class="hash-link" href="#node" title="Direct link to heading">#</a></h4><img alt="Kubernetes Flow" src="/img/compute.png"><p>A <a href="https://kubernetes.io/docs/concepts/architecture/nodes/" target="_blank" rel="noopener noreferrer">node</a> is the smallest unit of computing hardware in Kubernetes. It is a representation of a single machine in your cluster. In most production systems, a node will likely be either a physical machine in a datacenter, or virtual machine hosted on a cloud provider like <a href="https://cloud.google.com/" target="_blank" rel="noopener noreferrer">Google Cloud Platform</a>. Don’t let conventions limit you, however; in theory, you can make a node out of <a href="https://twitter.com/jkrippy/status/932800484703862784" target="_blank" rel="noopener noreferrer">almost</a> <a href="https://blog.hypriot.com/post/setup-kubernetes-raspberry-pi-cluster/" target="_blank" rel="noopener noreferrer">anything</a>. Thinking of a machine as a “node” allows us to insert a layer of abstraction. Now, instead of worrying about the unique characteristics of any individual machine, we can instead simply view each machine as a set of CPU and RAM resources that can be utilized. In this way, any machine can substitute any other machine in a Kubernetes cluster.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="the-cluster"></a>The Cluster<a aria-hidden="true" tabindex="-1" class="hash-link" href="#the-cluster" title="Direct link to heading">#</a></h4><img alt="Kubernetes Flow" src="/img/nodes.png"><p>Although working with individual nodes can be useful, it’s not the Kubernetes way. In general, you should think about the cluster as a whole, instead of worrying about the state of individual nodes. In Kubernetes, nodes pool together their resources to form a more powerful machine. When you deploy programs onto the cluster, it intelligently handles distributing work to the individual nodes for you. If any nodes are added or removed, the cluster will shift around work as necessary. It shouldn’t matter to the program, or the programmer, which individual machines are actually running the code. If this kind of hivemind-like system reminds you of the <a href="http://memory-alpha.wikia.com/wiki/Borg" target="_blank" rel="noopener noreferrer">Borg from Star Trek</a>, you’re not alone; “Borg” is the name for the <a href="http://blog.kubernetes.io/2015/04/borg-predecessor-to-kubernetes.html" target="_blank" rel="noopener noreferrer">internal Google project</a>Kubernetes was based on.</p><p><strong>Persistent Volumes</strong> Because programs running on your cluster aren’t guaranteed to run on a specific node, data can’t be saved to any arbitrary place in the file system. If a program tries to save data to a file for later, but is then relocated onto a new node, the file will no longer be where the program expects it to be. For this reason, the traditional local storage associated to each node is treated as a temporary cache to hold programs, but any data saved locally can not be expected to persist</p><p><img src="https://cdn-images-1.medium.com/max/1200/1*kF57zE9a5YCzhILHdmuRvQ.png"></p><p>To store data permanently, Kubernetes uses <a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener noreferrer">Persistent Volumes</a>. While the CPU and RAM resources of all nodes are effectively pooled and managed by the cluster, persistent file storage is not. Instead, local or cloud drives can be attached to the cluster as a Persistent Volume. This can be thought of as plugging an external hard drive in to the cluster. Persistent Volumes provide a file system that can be mounted to the cluster, without being associated with any particular node.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="software"></a>Software<a aria-hidden="true" tabindex="-1" class="hash-link" href="#software" title="Direct link to heading">#</a></h3><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="containers"></a>Containers<a aria-hidden="true" tabindex="-1" class="hash-link" href="#containers" title="Direct link to heading">#</a></h4><p><a href="https://camo.githubusercontent.com/29690b72d0d0be8349cf6965fbc67395bb050535/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a494c696e7a7a4d646e44356f513654753262664267512e706e67" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/29690b72d0d0be8349cf6965fbc67395bb050535/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f312a494c696e7a7a4d646e44356f513654753262664267512e706e67"></a><a href="https://camo.githubusercontent.com/b1285eef90c7a9f60cd200abe32af08b8710424a/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323030302f312a494c696e7a7a4d646e44356f513654753262664267512e706e67" target="_blank" rel="noopener noreferrer"><img src="https://camo.githubusercontent.com/b1285eef90c7a9f60cd200abe32af08b8710424a/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f323030302f312a494c696e7a7a4d646e44356f513654753262664267512e706e67"></a></p><p>Programs running on Kubernetes are packaged as <a href="https://www.docker.com/what-container" target="_blank" rel="noopener noreferrer">Linux containers</a>. Containers are a widely accepted standard, so there are already many <a href="https://hub.docker.com/explore/" target="_blank" rel="noopener noreferrer">pre-built images</a> that can be deployed on Kubernetes. Containerization allows you to create self-contained Linux execution environments. Any program and all its dependencies can be bundled up into a single file and then shared on the internet. Anyone can download the container and deploy it on their infrastructure with very little setup required. Creating a container can be done programmatically, allowing powerful <a href="http://blog.sonatype.com/achieving-ci/cd-with-kubernetes" target="_blank" rel="noopener noreferrer">CI and CD</a> pipelines to be formed. Multiple programs can be added into a single container, but you should limit yourself to one process per container if at all possible. It’s better to have many small containers than one large one. If each container has a tight focus, updates are easier to deploy and issues are easier to diagnose.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="pod"></a>Pod<a aria-hidden="true" tabindex="-1" class="hash-link" href="#pod" title="Direct link to heading">#</a></h4><p><img src="https://cdn-images-1.medium.com/max/1600/1*8OD0MgDNu3Csq0tGpS8Obg.png"></p><p>Unlike other systems you may have used in the past, Kubernetes doesn’t run containers directly; instead it wraps one or more containers into a higher-level structure called a <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener noreferrer">pod</a>. Any containers in the same pod will share the same resources and local network. Containers can easily communicate with other containers in the same pod as though they were on the same machine while maintaining a degree of isolation from others. Pods are used as the unit of replication in Kubernetes. If your application becomes too popular and a single pod instance can’t carry the load, Kubernetes can be configured to deploy new replicas of your pod to the cluster as necessary. Even when not under heavy load, it is standard to have multiple copies of a pod running at any time in a production system to allow load balancing and failure resistance. Pods can hold multiple containers, but you should limit yourself when possible. Because pods are scaled up and down as a unit, all containers in a pod must scale together, regardless of their individual needs. This leads to wasted resources and an expensive bill. To resolve this, pods should remain as small as possible, typically holding only a main process and its tightly-coupled helper containers (these helper containers are typically referred to as “side-cars”).</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="deployment"></a>Deployment<a aria-hidden="true" tabindex="-1" class="hash-link" href="#deployment" title="Direct link to heading">#</a></h4><p><img src="https://cdn-images-1.medium.com/max/1600/1*iTAVk3glVD95hb-X3HiCKg.png"></p><p>Although pods are the basic unit of computation in Kubernetes, they are not typically directly launched on a cluster. Instead, pods are usually managed by one more layer of abstraction: the <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/" target="_blank" rel="noopener noreferrer">deployment</a>. A deployment’s primary purpose is to declare how many replicas of a pod should be running at a time. When a deployment is added to the cluster, it will automatically spin up the requested number of pods, and then monitor them. If a pod dies, the deployment will automatically re-create it. Using a deployment, you don’t have to deal with pods manually. You can just declare the desired state of the system, and it will be managed for you automatically.</p><h4><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="ingress"></a>Ingress<a aria-hidden="true" tabindex="-1" class="hash-link" href="#ingress" title="Direct link to heading">#</a></h4><p><img src="https://cdn-images-1.medium.com/max/1600/1*tBJ-_g4Mk5OkfzLEHrRsRw.png"></p><p>Using the concepts described above, you can create a cluster of nodes, and launch deployments of pods onto the cluster. There is one last problem to solve, however: allowing external traffic to your application. By default, Kubernetes provides isolation between pods and the outside world. If you want to communicate with a service running in a pod, you have to open up a channel for communication. This is referred to as ingress. There are multiple ways to add ingress to your cluster. The most common ways are by adding either an <a href="https://kubernetes.io/docs/concepts/services-networking/ingress/" target="_blank" rel="noopener noreferrer">Ingress</a> controller, or a <a href="https://kubernetes.io/docs/tasks/access-application-cluster/create-external-load-balancer/" target="_blank" rel="noopener noreferrer">LoadBalancer</a>. The exact tradeoffs between these two options are out of scope for this post, but you must be aware that ingress is something you need to handle before you can experiment with Kubernetes.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="deployment-primitives"></a>Deployment Primitives<a aria-hidden="true" tabindex="-1" class="hash-link" href="#deployment-primitives" title="Direct link to heading">#</a></h2><p>Kubernetes has many things</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-text codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">NAME                              SHORTNAMES   APIGROUP                       NAMESPACED   KIND</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">bindings                                                                      true         Binding</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">componentstatuses                 cs                                          false        ComponentStatus</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">configmaps                        cm                                          true         ConfigMap</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">endpoints                         ep                                          true         Endpoints</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">events                            ev                                          true         Event</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">limitranges                       limits                                      true         LimitRange</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">namespaces                        ns                                          false        Namespace</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">nodes                             no                                          false        Node</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">persistentvolumeclaims            pvc                                         true         PersistentVolumeClaim</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">persistentvolumes                 pv                                          false        PersistentVolume</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">pods                              po                                          true         Pod</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">podtemplates                                                                  true         PodTemplate</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">replicationcontrollers            rc                                          true         ReplicationController</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">resourcequotas                    quota                                       true         ResourceQuota</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">secrets                                                                       true         Secret</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">serviceaccounts                   sa                                          true         ServiceAccount</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">services                          svc                                         true         Service</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">initializerconfigurations                      admissionregistration.k8s.io   false        InitializerConfiguration</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">mutatingwebhookconfigurations                  admissionregistration.k8s.io   false        MutatingWebhookConfiguration</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">validatingwebhookconfigurations                admissionregistration.k8s.io   false        ValidatingWebhookConfiguration</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">customresourcedefinitions         crd,crds     apiextensions.k8s.io           false        CustomResourceDefinition</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">apiservices                                    apiregistration.k8s.io         false        APIService</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">controllerrevisions                            apps                           true         ControllerRevision</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">daemonsets                        ds           apps                           true         DaemonSet</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">deployments                       deploy       apps                           true         Deployment</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">replicasets                       rs           apps                           true         ReplicaSet</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">statefulsets                      sts          apps                           true         StatefulSet</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">meshpolicies                                   authentication.istio.io        false        MeshPolicy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">policies                                       authentication.istio.io        true         Policy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">tokenreviews                                   authentication.k8s.io          false        TokenReview</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">localsubjectaccessreviews                      authorization.k8s.io           true         LocalSubjectAccessReview</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">selfsubjectaccessreviews                       authorization.k8s.io           false        SelfSubjectAccessReview</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">selfsubjectrulesreviews                        authorization.k8s.io           false        SelfSubjectRulesReview</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">subjectaccessreviews                           authorization.k8s.io           false        SubjectAccessReview</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">horizontalpodautoscalers          hpa          autoscaling                    true         HorizontalPodAutoscaler</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">cronjobs                          cj           batch                          true         CronJob</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">jobs                                           batch                          true         Job</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">certificatesigningrequests        csr          certificates.k8s.io            false        CertificateSigningRequest</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">certificates                      cert,certs   certmanager.k8s.io             true         Certificate</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">challenges                                     certmanager.k8s.io             true         Challenge</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">clusterissuers                                 certmanager.k8s.io             false        ClusterIssuer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">issuers                                        certmanager.k8s.io             true         Issuer</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">orders                                         certmanager.k8s.io             true         Order</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">leases                                         coordination.k8s.io            true         Lease</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">events                            ev           events.k8s.io                  true         Event</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">daemonsets                        ds           extensions                     true         DaemonSet</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">deployments                       deploy       extensions                     true         Deployment</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">ingresses                         ing          extensions                     true         Ingress</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">networkpolicies                   netpol       extensions                     true         NetworkPolicy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">podsecuritypolicies               psp          extensions                     false        PodSecurityPolicy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">replicasets                       rs           extensions                     true         ReplicaSet</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">nodes                                          metrics.k8s.io                 false        NodeMetrics</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">pods                                           metrics.k8s.io                 true         PodMetrics</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">networkpolicies                   netpol       networking.k8s.io              true         NetworkPolicy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">poddisruptionbudgets              pdb          policy                         true         PodDisruptionBudget</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">podsecuritypolicies               psp          policy                         false        PodSecurityPolicy</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">clusterrolebindings                            rbac.authorization.k8s.io      false        ClusterRoleBinding</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">clusterroles                                   rbac.authorization.k8s.io      false        ClusterRole</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">rolebindings                                   rbac.authorization.k8s.io      true         RoleBinding</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">roles                                          rbac.authorization.k8s.io      true         Role</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">priorityclasses                   pc           scheduling.k8s.io              false        PriorityClass</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">storageclasses                    sc           storage.k8s.io                 false        StorageClass</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">volumeattachments                              storage.k8s.io                 false        VolumeAttachment</span></div></div></div></div></div><p>To get our app to run on K8S we don&#x27;t need to know all of them. At the bare minimum we need to deal with 3 of these. Pods, Deployments and Services.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="pods"></a>Pods<a aria-hidden="true" tabindex="-1" class="hash-link" href="#pods" title="Direct link to heading">#</a></h3><p>Pods is the smallest unit in kubernetes. Each pod has to have atleast one container. But can have more. In some advanced kubernetes setup there are more that one container. Sidecar container, init container etc. </p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-text codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">apiVersion: v1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">kind: Pod</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">metadata:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  name: pod-example</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">spec:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  containers:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  - name: ubuntu</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    image: ubuntu:trusty</span></div></div></div></div></div><p>This is the most minimal pod you can create. </p><table><thead><tr><th align="left">Field</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code>apiVersion</code> string</td><td align="left">APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: <a href="https://git.k8s.io/community/contributors/devel/api-conventions.md%5C#resources" target="_blank" rel="noopener noreferrer">https://git.k8s.io/community/contributors/devel/api-conventions.md\#resources</a></td></tr><tr><td align="left"><code>kind</code> string</td><td align="left">Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: <a href="https://git.k8s.io/community/contributors/devel/api-conventions.md%5C#types-kinds" target="_blank" rel="noopener noreferrer">https://git.k8s.io/community/contributors/devel/api-conventions.md\#types-kinds</a></td></tr><tr><td align="left"><code>metadata</code> <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#objectmeta-v1-meta" target="_blank" rel="noopener noreferrer">ObjectMeta</a></td><td align="left">Standard object&#x27;s metadata. More info: <a href="https://git.k8s.io/community/contributors/devel/api-conventions.md%5C#metadata" target="_blank" rel="noopener noreferrer">https://git.k8s.io/community/contributors/devel/api-conventions.md\#metadata</a></td></tr><tr><td align="left"><code>spec</code> <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.14/#podspec-v1-core" target="_blank" rel="noopener noreferrer">PodSpec</a></td><td align="left">Specification of the desired behavior of the pod. More info: <a href="https://git.k8s.io/community/contributors/devel/api-conventions.md%5C#spec-and-status" target="_blank" rel="noopener noreferrer">https://git.k8s.io/community/contributors/devel/api-conventions.md\#spec-and-status</a></td></tr></tbody></table><p>In k8s we should never create a pod this way. Because pods by itself can not self restart or scale if needed.</p><p>For that we use a replicaset or deployment.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="deployment-1"></a>Deployment<a aria-hidden="true" tabindex="-1" class="hash-link" href="#deployment-1" title="Direct link to heading">#</a></h3><p>A <em>Deployment</em> controller provides declarative updates for <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener noreferrer">Pods</a> and <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener noreferrer">ReplicaSets</a>.</p><p>You describe a <em>desired state</em> in a Deployment object, and the Deployment controller changes the actual state to the desired state at a controlled rate. You can define Deployments to create new ReplicaSets, or to remove existing Deployments and adopt all their resources with new Deployments.</p><p>The quick and dirty way to create a deployment is to use the run command.</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-text codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">kubectl run nginx --image=nginx:1.10 --replicas=3</span></div></div></div></div></div><p>But this is not preferred because its not reproducible. We should use a yaml file and check it in version control. </p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-text codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">apiVersion: apps/v1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">kind: Deployment</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">metadata:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # Unique key of the Deployment instance</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  name: deployment-example</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">spec:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # 3 Pods should exist at all times.</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  replicas: 3</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  template:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    metadata:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      labels:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        # Apply this label to pods and default</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        # the Deployment label selector to this value</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        app: nginx</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    spec:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      containers:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      - name: nginx</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        # Run this image</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">        image: nginx:1.10</span></div></div></div></div></div><p>The pod spec is embedded in the deployment under template.</p><p>Finally we need a way to make the app available to the world. We use a service for that.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="service"></a>Service<a aria-hidden="true" tabindex="-1" class="hash-link" href="#service" title="Direct link to heading">#</a></h3><p>Kubernetes <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener noreferrer"><code>Pods</code></a> are mortal. They are born and when they die, they are not resurrected. <a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener noreferrer"><code>ReplicaSets</code></a> in particular create and destroy <code>Pods</code> dynamically (e.g. when scaling out or in). While each <code>Pod</code> gets its own IP address, even those IP addresses cannot be relied upon to be stable over time. This leads to a problem: if some set of <code>Pods</code> (let’s call them backends) provides functionality to other <code>Pods</code> (let’s call them frontends) inside the Kubernetes cluster, how do those frontends find out and keep track of which backends are in that set?</p><p>Enter <code>Services</code>.</p><p>A Kubernetes <code>Service</code> is an abstraction which defines a logical set of <code>Pods</code> and a policy by which to access them - sometimes called a micro-service. The set of <code>Pods</code> targeted by a <code>Service</code> is (usually) determined by a <a href="https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors" target="_blank" rel="noopener noreferrer"><code>Label Selector</code></a> (see below for why you might want a <code>Service</code> without a selector).</p><div class="mdxCodeBlock_1XEh"><div class="codeBlockContent_1u-d"><button type="button" aria-label="Copy code to clipboard" class="copyButton_10dd">Copy</button><div tabindex="0" class="prism-code language-text codeBlock_3iAC"><div class="codeBlockLines_b7E3" style="color:#bfc7d5;background-color:#292d3e"><div class="token-line" style="color:#bfc7d5"><span class="token plain">kind: Service</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">apiVersion: v1</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">metadata:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  # Unique key of the Service instance</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  name: service-example</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">spec:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  ports:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # Accept traffic sent to port 80</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    - name: http</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      port: 80</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">      targetPort: 80</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">  selector:</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    # this label selector</span></div><div class="token-line" style="color:#bfc7d5"><span class="token plain">    app: nginx</span></div></div></div></div></div><p>There are few types of services out there.</p><p>For some parts of your application (e.g. frontends) you may want to expose a Service onto an external (outside of your cluster) IP address.</p><p>Kubernetes <code>ServiceTypes</code> allow you to specify what kind of service you want. The default is <code>ClusterIP</code>.</p><p><code>Type</code> values and their behaviors are:</p><ul><li><code>ClusterIP</code>: Exposes the service on a cluster-internal IP. Choosing this value makes the service only reachable from within the cluster. This is the default <code>ServiceType</code>.</li><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#nodeport" target="_blank" rel="noopener noreferrer"><code>NodePort</code></a>: Exposes the service on each Node’s IP at a static port (the <code>NodePort</code>). A <code>ClusterIP</code> service, to which the <code>NodePort</code> service will route, is automatically created. You’ll be able to contact the <code>NodePort</code> service, from outside the cluster, by requesting <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code>.</li><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer" target="_blank" rel="noopener noreferrer"><code>LoadBalancer</code></a>: Exposes the service externally using a cloud provider’s load balancer. <code>NodePort</code> and <code>ClusterIP</code> services, to which the external load balancer will route, are automatically created.</li><li><a href="https://kubernetes.io/docs/concepts/services-networking/service/#externalname" target="_blank" rel="noopener noreferrer"><code>ExternalName</code></a>: Maps the service to the contents of the <code>externalName</code> field (e.g. <code>foo.bar.example.com</code>), by returning a <code>CNAME</code> record with its value. No proxying of any kind is set up. This requires version 1.7 or higher of <code>kube-dns</code>.</li></ul><p>ClusterIP is cluster internal. We will see both ClusterIP and LoadBalancer in depth in a second.</p></div></article><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/docs/python"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">« Python</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/docs/openshift"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Openshift »</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3SO_"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#why-do-i-need-kubernetes-and-what-can-it-do" class="table-of-contents__link">Why do I need Kubernetes and what can it do?</a></li><li><a href="#what-kubernetes-is-not" class="table-of-contents__link">What Kubernetes is not</a></li><li><a href="#why-containers" class="table-of-contents__link">Why containers</a></li><li><a href="#kubernetes-architecture" class="table-of-contents__link">Kubernetes architecture</a><ul><li><a href="#kubernetes-resource-model" class="table-of-contents__link">Kubernetes resource model</a></li><li><a href="#hardware" class="table-of-contents__link">Hardware</a></li><li><a href="#software" class="table-of-contents__link">Software</a></li></ul></li><li><a href="#deployment-primitives" class="table-of-contents__link">Deployment Primitives</a><ul><li><a href="#pods" class="table-of-contents__link">Pods</a></li><li><a href="#deployment-1" class="table-of-contents__link">Deployment</a></li><li><a href="#service" class="table-of-contents__link">Service</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/docs/">Introduction</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">Community</h4><ul class="footer__items"><li class="footer__item"><a href="https://developer.ibm.com" target="_blank" rel="noopener noreferrer" class="footer__link-item">IBM Developer</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a href="https://github.com/facebook/docusaurus" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li><li class="footer__item"><a href="https://www.crowdcast.io/ibmdeveloper" target="_blank" rel="noopener noreferrer" class="footer__link-item">Crowdcast</a></li></ul></div></div><div class="text--center"><div></div></div></div></footer></div>
<script src="/styles.b8ff35c3.js"></script>
<script src="/runtime~main.f20a1611.js"></script>
<script src="/main.3c1da133.js"></script>
<script src="/1.2594eb98.js"></script>
<script src="/2.60cd53ed.js"></script>
<script src="/23.4bf89ce8.js"></script>
<script src="/24.ce4b8b15.js"></script>
<script src="/935f2afb.60f6c2a3.js"></script>
<script src="/17896441.787198e7.js"></script>
<script src="/008e8819.39eae513.js"></script>
</body>
</html>